//#define _CRT_SECURE_NO_WARNINGS 1
//#include<stdio.h>
//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	return 0;
//}
//10000000 00000000 00000000 00010100
//11111111 11111111 11111111 11101011
//11111111 11111111 11111111 11101100    -20补码
//00000000 00000000 00000000 00001010     10补码
//11111111 11111111 11111111 11110110       结果
//11111111 11111111 11111111 11110101
//00000000 00000000 00000000 00001010     -10
//#include<stdio.h>
//int main()
//{
//	unsigned int i;
//	for(i=9;i>=0;i--)//无符号整形最后减到-1，可是i是无符号整形所以被视为40亿的那个
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}
//#include<stdio.h>
//#include<string.h>
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//
//	}
//	printf("%d", strlen(a));//这道题答案输出255，char类型范围为-128到127，
//	return 0;
//}
//-1 -2 -3 -4.....-128 -129(127)-130(126)....0(0)那么从-1到-128再从127->1就是128加上127就是255个遇到0结束
//所以\0之前是255个
//#include<stdio.h>
//int main()
//{
//	unsigned char i = 0;
//	for (i = 0; i <= 255; i++)
//	{
//		printf("helloworld\n");//死循环
//	}
//
//	return 0;
//}
//总结：无符号数不要乱用，特别容易会让程序死循环
//浮点的存储
//3.14 ,1e10//short long int在<limits.h>float double看范围<float.h>vs里面vc里面的include里面就是这些头文件
//#include<stdio.h>
//int main()
//{
//	int n = 9;
// //00000000 00000000 00000000 00001001 9的补码
// //我pfloat就认为我这个里面放的就是浮点数
// //那就直接划分s 1e8 m23了
// //(-1)^0*0.000000 00000000 00001001*2^-126.默认6位打印出，那就是0.000000
//	float* pfloat = (float*)&n;
//	printf("n的值为：%d\n", n);
//	printf("*pfloat的值为：%f\n", *pfloat);
//	*pfloat = 9.0;//那我现在就是要把9.0存进去
// //0 10000011 00100000000000000000000
// //那我现在它认为是个整数打印那么那个数就是特别大的
//	printf("n的值为：%d\n", n);
//	printf("*pfloat的值为：%f\n", *pfloat);
//	return 0;
//}
//n的值为：9
//*pfloat的值为：0.000000
//n的值为：1091567616
//* pfloat的值为：9.000000
//浮点数储存规定为（-1）s*M*2^E,s正为0负为1，M为科学计数法的那位，后面就是2的多少，小数点移动几位就是多少
//IEEE规定：对于32位的浮点数，最高位的一位为符号s
//接着的8位是指数E，接下来23位位有效数字M，s1bit e8bit m23bit
//32bit位那就是1 8 23
//64位那就是  1 11 52
//IEEE754规定m存放有效数字的时候一位1<=m<2所以如果写成1.。。。那么后面只能存22位了，
//因为前面总是1所以不写那个1了直接写小数点后面的提高一位精度
//那个e存放的就是无整形数，可是科学计数法是可以出现负数的，存储就很麻烦
//e在11位中0到2047在8位中0到255，所以我们设立了一个中间量，11位位1023,8位为127.
//0.5
// 0.1
//变成2进制
//(-1)的0次*1*2的-1次
//#include<stdio.h>
//int main()
//{
//	float f = 5.5;
//	//5.5
//	//101.1
//	//(-1)^0*1.011*2^2
//	//M=1.011
//	//E=2
//	//2+127=129
//	//0|10000001|01100000000000000000000
//	//16进制0x40b00000
//	return 0;
//}
//指数E取有三种情况
//不为全0或全1将这个值减去127就是E真实值
//前面补1
//E为全0
//真实的E是-127
// 那么这个E导出的时候是及其不一样的因为这个数小的实在没有母亲所以就定义
// 导出的时候真实E视为1-127或者1-1023，而且前面也不加第一位1了写成0.。。。
//E全为1
//如果全为1也就是这个E是128，那么这个数大的没有母亲如果有效数字全为0那么就看s，s正就无穷大反之无穷小
//表示无穷大的数字