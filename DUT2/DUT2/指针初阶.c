//#define _CRT_SECURE_NO_WARNINGS 1
//无论用char*a来接受一个整形的地址还是用int*b来接受那个整形的值打印地址的时候都是可以的
//可是如果你用*a=0；和*b=0；操作后是不一样的，在内存中，*a因为定义是整形所以操作了那个整形整个的数值(4个字节)
//但是第二个只是操作16进制位的最后2位（1个字节）
//指针类型决定了进行解引用操作时能够访问空间的大小。
//指针类型决定了走一步跳多远打印地址的时候加1，int加4，double加8
//#include<stdio.h>
//int main()
//{
//	int arr[10] = { 6,1,4294967295,2,4,5,6,7,8,9 };
//	char* p = &arr;
//	int i;
//	for (i = 0; i < 10; i++)
//	{
//		*(p + i) = 0;
//	}
//	printf("%d", arr[2]);
//	return 0;
//}
//野指针：指向位置不一定的指针
//1.指针未初始化
//2.指针越界访问（比如你定义*p是arr的地址然后你让p一直加加到arr所定义范围之外）
//3.指针所指向的那块空间释放、
//#include<stdio.h>
//int* test()
//{
//	static int a = 10;//static可以保证a的地址出这个自定义函数不销毁
//	return &a;
//}
//int main()
//{
//	int* p = test();
//*p = 20;
//printf("%d", *p);
//	return 0;
//}
//函数结束后a的那块空间还给系统了，虽然p接受到了a地址但是已经晚了




